<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Frequent Items Estimation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c5a5d5e27fcc88644031c24cff017230.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="shortcut icon" href="../favicon.ico">
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GZHXTPTRRE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GZHXTPTRRE');
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Spring 2026</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://discord.gg/dES3fSPEeC"> 
<span class="menu-text">Discord</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.gradescope.com/courses/1233250"> 
<span class="menu-text">Gradescope</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#hash-functions" id="toc-hash-functions" class="nav-link active" data-scroll-target="#hash-functions">Hash Functions</a></li>
  <li><a href="#count-min-sketch" id="toc-count-min-sketch" class="nav-link" data-scroll-target="#count-min-sketch">Count-Min Sketch</a></li>
  <li><a href="#union-bound" id="toc-union-bound" class="nav-link" data-scroll-target="#union-bound">Union Bound</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Frequent Items Estimation</strong></h1>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<p>The frequent items problem is to identify the items that appear most often in a stream. For example, we may want to find the most popular products on Amazon, the most watched videos on YouTube, or the most searched queries on Google. We process each item as it appears in the stream and, at any moment, our goal is to return the most frequent items <em>without</em> having to scan through a database.</p>
<p>The obvious algorithm for the frequent items problem is to store each item and the number of times we’ve seen it. The issue is that we would then need space linear in the number of unique items. If the items are pairs of products, for example, then the space scales quadratically. If the items are triplets of videos, then the space scales cubically. Clearly, we need a more efficient algorithm. It turns out that we can’t solve the problem exactly with less space but we can solve the problem <em>approximately</em>.</p>
<p>Consider a stream of <span class="math inline">\(n\)</span> items <span class="math inline">\(x_1, \ldots, x_n\)</span>. We’ll call the set of all items in the stream <span class="math inline">\(U\)</span>. Let <span class="math inline">\(k\)</span> be a positive integer and <span class="math inline">\(\epsilon &gt; 0\)</span> be a small constant. The frequent items estimation problem is to return</p>
<ul>
<li><p>every item that appears at least <span class="math inline">\(\frac{n}{k}\)</span> times and</p></li>
<li><p>only items that appear at least <span class="math inline">\((1-\epsilon)\frac{n}{k}\)</span> times.</p></li>
</ul>
<p>We’ll see how to use a randomized hashing algorithm to solve the problem. The algorithm addresses the slightly different problem of estimating the frequency of any item <span class="math inline">\(v\)</span> in the stream. Formally, let <span class="math inline">\(f(v) = \sum_{i=1}^n \mathbb{1}[x_i=v]\)</span> be the number of times item <span class="math inline">\(v\)</span> appears in the stream. Here, we use the notation <span class="math inline">\(\mathbb{1}[x_i=v]\)</span> to denote the indicator random variable that the <span class="math inline">\(i\)</span>th item in the stream is <span class="math inline">\(v\)</span>. An indicator random variable is 1 if the event happens and 0 otherwise.</p>
<p>Our goal is to return an estimate <span class="math inline">\(\hat{f}(v)\)</span> so that <span class="math inline">\(f(v) \leq \hat{f}(v) \leq f(v) + \frac{\epsilon}{k} n\)</span> with high probability. If we have these estimates, observe that we can can solve the frequent items estimation problem simply by returning all items for which <span class="math inline">\(\hat{f}(v) \geq \frac{n}{k}\)</span>.</p>
<p>The key ingredient of the algorithm is hash functions.</p>
<section id="hash-functions" class="level3">
<h3 class="anchored" data-anchor-id="hash-functions">Hash Functions</h3>
<p>Let the hash function <span class="math inline">\(h\)</span> be a random function from the set of all items <span class="math inline">\(\mathcal{U}\)</span> to the integers <span class="math inline">\(\{1,\ldots, m\}\)</span>. The hash function is constructed using a seed of random numbers and then the function is fixed. Given an item <span class="math inline">\(x\)</span>, the hash function always returns the same hashed output <span class="math inline">\(h(x)\)</span>.</p>
<p><strong>Definition:</strong> A hash function <span class="math inline">\(h: \mathcal{U} \to \{1, \ldots, m\}\)</span> is uniform random if</p>
<ul>
<li><p><span class="math inline">\(\Pr(h(x)=i) = \frac{1}{m}\)</span> for all items <span class="math inline">\(x\)</span> and <span class="math inline">\(i \in \{1, \ldots, m\}\)</span> and</p></li>
<li><p><span class="math inline">\(h(x)\)</span> and <span class="math inline">\(h(y)\)</span> are independent random variables for all <span class="math inline">\(x,y \in U\)</span>.</p></li>
</ul>
<p>Notice that the independence condition implies <span class="math inline">\(\Pr(h(x)=h(y)) = \frac{1}{m}\)</span>.</p>
<p>In general, it is not possible to efficiently implement uniform random hash functions. But, for our application, we only need a universal hash function which <em>can</em> be implemented efficiently. Let <span class="math inline">\(p\)</span> be a prime number between <span class="math inline">\(|\mathcal{U}|\)</span> and <span class="math inline">\(2|\mathcal{U}|\)</span>. Choose <span class="math inline">\(a,b\)</span> randomly from <span class="math inline">\(0,\ldots,p\)</span> so that <span class="math inline">\(a \neq 0\)</span>, then define the hash function <span class="math display">\[h(x) = (a x + b \mod p) \mod m.\]</span> Check out <a href="https://www.cs.princeton.edu/courses/archive/fall18/cos521/Lectures/lec1.pdf">these lecture notes</a> to learn why <span class="math inline">\(\Pr(h(x) = h(y)) \leq \frac{1}{m}\)</span> for this hash function. (As we’ll soon see, this is the condition we need for the algorithm.)</p>
</section>
<section id="count-min-sketch" class="level3">
<h3 class="anchored" data-anchor-id="count-min-sketch">Count-Min Sketch</h3>
<p>With handy hash functions, we’re now ready to describe the algorithm. We first choose a random hash function <span class="math inline">\(h\)</span> and initialize an <span class="math inline">\(m\)</span>-length array with <span class="math inline">\(0\)</span> in every cell. Items arrive in a stream and we hash each one to one of the <span class="math inline">\(m\)</span> cells in the array. We then add 1 to the number in the cell. Formally, given item <span class="math inline">\(x_i\)</span>, we set <span class="math inline">\(A[h(x_i)] = A[h(x_i)]+1\)</span>.</p>
<center>
<img src="images/count.png" width="600">
</center>
<p>In the figure, Amazon products appear one after the other in a stream. We hash the fish tank to the second cell in the array, the basketball to the first cell, and so on. Crucially, when we see the fish tank again, we hash it to the same cell.</p>
<p>After processing the stream, our estimate for the frequency of item <span class="math inline">\(v\)</span> is <span class="math inline">\(\hat{f}(v) = A[h(v)]\)</span>. Notice that <span class="math inline">\(\hat{f}(v) \geq f(v)\)</span> since every time we saw item <span class="math inline">\(v\)</span>, we added 1 to the corresponding cell in the array. The inequality appears because we could have overcounted when other items hash to the same cell.</p>
<p>Formally, our estimate for the frequency is <span class="math display">\[
\hat{f}(v) = f(v) + \sum_{y \in \mathcal{U} \setminus v} f(y) \mathbb{1}[h(y)=h(v)].
\]</span> Our estimate for the frequency contains the true frequency plus an error term for all the other items that are hashed to the same cell.</p>
<p>Let’s take the expectation of the error term: <span class="math display">\[
\mathbb{E}\left[\sum_{y \in U \setminus v} f(y) \mathbb{1}[h(y)=h(v)]\right]
= \sum_{y \in \mathcal{U} \setminus v} f(y) \mathbb{E}[\mathbb{1}[h(y)=h(v)]]
\]</span> <span class="math display">\[
\leq \sum_{y \in \mathcal{U} \setminus v} f(y) \frac{1}{m} = \frac{1}{m} \sum_{y \in \mathcal{U} \setminus v} f(y) \leq \frac{n}{m}.
\]</span> We used linearity of expectation, the special property of indicator random variables and the probability of collisions in our hash function in the first inequality. We used that the sum of frequencies has to sum to <span class="math inline">\(n\)</span> in the last equality.</p>
<p>We have a non-negative random variable and a bound on its expectation, let’s apply Markov’s inequality to the error term</p>
<p><span class="math display">\[
\Pr\left( \sum_{y \in \mathcal{U} \setminus v} f(y) \mathbb{1}[h(y)=h(v)] \geq \frac{2n}{m} \right)
\leq \frac{n/m}{2n/m} = \frac{1}{2}.
\]</span> So we’ve shown that our estimate <span class="math inline">\(A[h(v)]\)</span> satisfies</p>
<p><span class="math display">\[
f(v) \leq A[h(v)] \leq f(v) + \frac{2n}{m}
\]</span> with probability <span class="math inline">\(\frac{1}{2}\)</span> for any <span class="math inline">\(v\)</span>. If we set <span class="math inline">\(m = \frac{2k}{\epsilon}\)</span>, we can solve the problem with error <span class="math inline">\(\frac{\epsilon n}{k}\)</span>. But our success probability is a little low, how can we improve it?</p>
<p>A common approach in many randomized algorithms is to boost the success probability by repeating the core subroutine. In our case, we’ll maintain <span class="math inline">\(t\)</span> independent hash functions and arrays.</p>
<center>
<img src="images/count_min.png" width="600">
</center>
<p>As depicted in the figure, each item gets hashed into one cell in every array using the respective hash function. So the update on item <span class="math inline">\(x_i\)</span> for every array <span class="math inline">\(j \in \{1, \ldots, t\}\)</span> is <span class="math inline">\(A_j[h_j(x_i)] = A_j[h_j(x_i)] + 1\)</span>.</p>
<p>Then, when we’re computing our estimate for the frequnecy of an item, we look at each cell it appears in and take the minimum. Formally, <span class="math inline">\(\hat{f}(v) = \min A_j[h_j(v)]\)</span>. We take the minimum because each array only has one-sided error; its estimate for the frequency is never <em>smaller</em> than the true frequency. If our estimates instead had two-sided error, we would prefer to take the mean or median.</p>
<p>For every array <span class="math inline">\(j\)</span> and item <span class="math inline">\(v\)</span> when we set <span class="math inline">\(m=\frac{2k}{\epsilon}\)</span>, we know that <span class="math inline">\(f(v) \leq A_j[h_j(v)] \leq f(v) + \frac{\epsilon n}{k}\)</span> with probability <span class="math inline">\(\frac{1}{2}\)</span>. Let’s compute the probability that our final estimate has this much error.</p>
<p><span class="math display">\[
\Pr \left( \hat{f}(v) &gt; f(v) + \frac{\epsilon n}{k} \right)
\leq \left( \frac{1}{2} \right)^t
\]</span> Call the event that the frequency estimate has error more than <span class="math inline">\(\frac{\epsilon n}{k}\)</span> an error. The inequality holds since our final estimate fails only if every single one of the arrays also independently fails. If we set <span class="math inline">\(t=\log_2{1/\delta}\)</span> for some small constant <span class="math inline">\(\delta &gt; 0\)</span>, then the failure probability is <span class="math inline">\(\delta\)</span>. The success probability, the complement of the failure probability, is <span class="math inline">\(1-\delta\)</span>.</p>
<p>Putting it all together, we just proved that count-min sketch lets us estimate the frequency of each item in the stream up to error <span class="math inline">\(\frac{\epsilon n}{k}\)</span> with probability at least <span class="math inline">\(1-\delta\)</span> in <span class="math inline">\(O(mt) = O(\log(1/\delta) \frac{k}{\epsilon})\)</span> space. The first term in the space complexity comes from the number of arrays <span class="math inline">\(t\)</span> and the second term comes from the space per array <span class="math inline">\(m\)</span>.</p>
<p>However, this guarantee is only <em>for a single</em> item <span class="math inline">\(v\)</span>. We really want a guarantee <em>for all</em> items.</p>
</section>
<section id="union-bound" class="level3">
<h3 class="anchored" data-anchor-id="union-bound">Union Bound</h3>
<p>Another simple and powerful tool in randomized algorithm design is the union bound. The union bound allows us to easily analyze the complicated dynamics of many random events.</p>
<p><strong>Lemma:</strong> For any random events <span class="math inline">\(E_1, E_2, \ldots, E_k\)</span>,</p>
<p><span class="math display">\[
\Pr(E_1 \cup E_2 \cup \ldots \cup E_k)
\leq \Pr(E_1) + \Pr(E_2) + \ldots + \Pr(E_k).
\]</span></p>
<p><strong>Proof:</strong> We’ll give a “proof by picture”. Each circle represents the outcome space corresponding to event <span class="math inline">\(E_i\)</span>. The total outcome space covered by any overlapping events is at most the outcome space covered by the events if they were to not overlap.</p>
<center>
<img src="images/union.png" width="600">
</center>
<p>Let’s apply the union bound to the total failure probability of our estimate. The algorithm fails if <span class="math inline">\(\hat{f}(v_i) &gt; f(v_i) + \frac{\epsilon n }{k}\)</span> for any item <span class="math inline">\(v_i\)</span>. By the union bound, <span class="math display">\[
\Pr \left(
\textrm{fail for } v_1
\cup \textrm{fail for } v_2
\cup \ldots \cup
\textrm{fail for } v_{|\mathcal{U}|}
\right)
\]</span> <span class="math display">\[
\leq \Pr(\textrm{fail for } v_1)
+ \Pr(\textrm{fail for } v_2)
+ \ldots +
\Pr(\textrm{fail for } v_{|\mathcal{U}|})
\]</span> <span class="math display">\[
= \delta + \delta + \ldots + \delta = |\mathcal{U}| \delta \leq n \delta.
\]</span> Let’s set <span class="math inline">\(\delta=\frac{1}{10n}\)</span>. With probability <span class="math inline">\(9/10\)</span>, count-min sketch lets us estimate the frequency of all items in a stream up to error <span class="math inline">\(\frac{\epsilon n}{k}\)</span>. Recall this is is accurate enough to solve the frequent items estimation problem if we just return all items <span class="math inline">\(v\)</span> with estimated frequency at least <span class="math inline">\(\frac{n}{k}\)</span>.</p>



</section>

</main> <!-- /main -->
<script>
document.addEventListener("DOMContentLoaded", function () {
  const wordsPerMinute = 200;
  const text = document.body.innerText;
  const words = text.trim().split(/\s+/).length;
  const readingTime = Math.ceil(words / wordsPerMinute);

  const readTimeEl = document.createElement("div");
  readTimeEl.innerText = `⏱️ ${readingTime} min read`;

  // Style it to appear centered
  readTimeEl.style.fontSize = "0.9em";
  readTimeEl.style.margin = "1em auto";
  readTimeEl.style.textAlign = "left";
  readTimeEl.style.width = "100%";

  const title = document.querySelector("h1");
  if (title) {
    title.parentNode.insertBefore(readTimeEl, title.nextSibling);
  }
});
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>