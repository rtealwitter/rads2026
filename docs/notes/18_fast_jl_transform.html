<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fast Johnson-Lindenstrauss Transform</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c5a5d5e27fcc88644031c24cff017230.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="shortcut icon" href="../favicon.ico">
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GZHXTPTRRE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GZHXTPTRRE');
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Spring 2026</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://discord.gg/dES3fSPEeC"> 
<span class="menu-text">Discord</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.gradescope.com/courses/1091652"> 
<span class="menu-text">Gradescope</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Fast Johnson-Lindenstrauss Transform</strong></h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<p>Last class, we discussed how to speed up regression using randomization. Consider the feature matrix <span class="math inline">\(\mathbf{A} \in \mathbb{R}^{n \times d}\)</span> and target vector <span class="math inline">\(\mathbf{b} \in \mathbb{R}^n\)</span>. We wanted to find the least squares solution <span class="math display">\[\mathbf{x}^* = \arg\min_{\mathbf{x} \in \mathbb{R}^d} \|\mathbf{Ax} - \mathbf{b}\|_2^2.\]</span> But solving the problem directly is expensive: It would take <span class="math inline">\(O(nd^2)\)</span> time to compute the solution <span class="math inline">\(\mathbf{x}^*=(\mathbf{A}^\top \mathbf{A})^{-1} \mathbf{A}^\top \mathbf{b}\)</span> or <span class="math inline">\(O(nd)\cdot(\# \text{iterations})\)</span> time to compute the solution iteratively.</p>
<p>Instead, we used a random JL matrix <span class="math inline">\(\mathbf{\Pi} \in \mathbb{R}^{m \times n}\)</span> to reduce the dimension of the problem and find <span class="math display">\[
\tilde{\mathbf{x}} = \arg\min_{\mathbf{x} \in \mathbb{R}^m} \|\mathbf{\Pi Ax} - \mathbf{\Pi b}\|_2^2.
\]</span> It would take <span class="math inline">\(O(md^2)\)</span> time to compute the solution <span class="math inline">\(\tilde{\mathbf{x}}=(\mathbf{\Pi A}^\top \mathbf{\Pi A})^{-1} \mathbf{\Pi A}^\top \mathbf{\Pi b}\)</span> or <span class="math inline">\(O(md)\cdot(\# \text{iterations})\)</span> time to compute the solution iteratively.</p>
<p>But even computing <span class="math inline">\(\mathbf{\Pi A}\)</span> is expensive. Since <span class="math inline">\(\mathbf{\Pi}\)</span> is <span class="math inline">\(m \times n\)</span> and <span class="math inline">\(\mathbf{A}\)</span> is <span class="math inline">\(n \times d\)</span>, it would take <span class="math inline">\(O(mnd)=O(nd^2)\)</span> time to compute the matrix product <span class="math inline">\(\mathbf{\Pi A}\)</span>.</p>
<p>Our goal today is to develop faster Johnson-Lindenstrauss projections.</p>
<p align="center">
<img src="images/sparseJL.png" width="200px">
</p>
<p>Typically, we use sparse or structured matrices instead of fully random JL matrices because they are faster to compute.</p>
<p>We will develop a method that reduces a vector <span class="math inline">\(\mathbf{x} \in \mathbb{R}^n\)</span> down to <span class="math inline">\(m \approx \frac{\log(1/\delta)}{\epsilon^2}\)</span> dimensions in roughly <span class="math inline">\(O(n \log n)\)</span> time and guarantee that <span class="math display">\[
(1-\epsilon) \|\mathbf{x}\|_2^2 \leq \|\mathbf{\Pi x}\|_2^2 \leq (1+\epsilon) \|\mathbf{x}\|_2^2.
\]</span></p>
<p>Recall that once this bound is proven, linearity lets us preserve quantities like <span class="math inline">\(\| \mathbf{y} - \mathbf{x} \|_2\)</span> and <span class="math inline">\(\| \mathbf{Ax} - \mathbf{b} \|_2\)</span> for all <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p>Let <span class="math inline">\(\mathbf{S} \in \mathbb{R}^{m \times n}\)</span> be a random sampling matrix. Every row contains a value <span class="math inline">\(s=\sqrt{n/m}\)</span> in a single location and is zero everywhere else.</p>
<p align="center">
<img src="images/subsampling.png" width="200px">
</p>
<p>If we take <span class="math inline">\(m\)</span> samples, then <span class="math inline">\(\tilde{\mathbf{x}} = \mathbf{Sx}\)</span> is a random projection that can be computed in <span class="math inline">\(O(m)\)</span> time. But, there’s an issue. The approach only works well if <span class="math inline">\(\mathbf{x}\)</span> is “flat”.</p>
<p align="center">
<img src="images/uniform_hard.png" width="200px">
</p>
<p><strong>Claim:</strong> If <span class="math inline">\(\mathbf{x}_i ^2 \leq \frac{c}{n} \| \mathbf{x} \|_2^2\)</span> for all <span class="math inline">\(i\)</span>, then <span class="math inline">\(m = O(c \log(1/\delta) /\epsilon^2)\)</span> samples suffice to preserve the <span class="math inline">\(\ell_2\)</span>-norm within an <span class="math inline">\(\epsilon\)</span> multiplicative factor with probability <span class="math inline">\(1-\delta\)</span>.</p>
<p>The claim follows from the standard Hoeffding inequality.</p>
<p>Unfortunately, we can’t guarantee that <span class="math inline">\(\mathbf{x}\)</span> is flat. However, we can multiply by a <em>mixing matrix</em> <span class="math inline">\(\mathbf{M}\)</span> which ensures it cannot be too concentrated in one place.</p>
<p>We will show a mixing matrix <span class="math inline">\(\mathbf{M}\)</span> that satisfies the following properties:</p>
<ul>
<li><p><span class="math inline">\(\| \mathbf{Mx} \|_2^2 = \|\mathbf{x}\|_2^2\)</span> <em>exactly</em>.</p></li>
<li><p>Every entry in <span class="math inline">\(\mathbf{Mx}\)</span> is bounded. That is, <span class="math inline">\([\mathbf{Mx}]_i^2 \leq \frac{c}{n} \| \mathbf{x} \|_2^2\)</span> for some factor <span class="math inline">\(c\)</span>.</p></li>
<li><p>We can compute <span class="math inline">\(\mathbf{Mx}\)</span> in <span class="math inline">\(O(n \log n)\)</span> time.</p></li>
</ul>
<p>Then we will multiply by a subsampling matrix <span class="math inline">\(\mathbf{S}\)</span> to reduce the dimension. The projection is</p>
<p><span class="math display">\[\mathbf{\Pi x} = \mathbf{SM x}.\]</span></p>
<p>Good mixing matrices should look random. In fact, for <span class="math inline">\(\mathbf{Mx}\)</span> to preserve the <span class="math inline">\(\ell_2\)</span>-norm of any <span class="math inline">\(\mathbf{x}\)</span> with high probability, <span class="math inline">\(\mathbf{M}\)</span> must be a random matrix.</p>
<p>We can see this starting from the observation that <span class="math inline">\(\| \mathbf{Mx} \|_2^2 = \|\mathbf{x}\|_2^2\)</span> so <span class="math inline">\(\mathbf{M}\)</span> must be an orthogonal matrix. Since <span class="math inline">\(\mathbf{M}\)</span> is orthogonal, it has an inverse <span class="math inline">\(\mathbf{M}^{-1}\)</span>. Then we can solve for an <span class="math inline">\(\mathbf{x}\)</span> such that <span class="math inline">\(\mathbf{e}_1 = \mathbf{Mx}\)</span> where <span class="math inline">\(\mathbf{e}_1\)</span> is the first standard basis vector. In particular, <span class="math inline">\(\mathbf{x} = \mathbf{M}^{-1} \mathbf{e}_1\)</span>. If <span class="math inline">\(\mathbf{M}\)</span> is known in advance, we can adversarily choose <span class="math inline">\(\mathbf{x}\)</span> to give concentrated mass to the first coordinate. Our solution is to use a random mixing matrix <span class="math inline">\(\mathbf{M}\)</span> so that, with high probability, <span class="math inline">\(\mathbf{Mx}\)</span> is flat even if <span class="math inline">\(\mathbf{x}\)</span> is not.</p>
<p>We have argued that <span class="math inline">\(\mathbf{M}\)</span> must be a random orthogonal matrix. But, for our approach to work, we need to be able to compute <span class="math inline">\(\mathbf{Mx}\)</span> quickly. So we will use a <em>pseudorandom</em> matrix instead.</p>
<p>We will use the mixing matrix <span class="math inline">\(\mathbf{M} = \mathbf{HD}\)</span> where:</p>
<ul>
<li><p><span class="math inline">\(\mathbf{D} \in \mathbb{R}^{n \times n}\)</span> is a diagonal matrix with the diagonal entries <span class="math inline">\(D_{i,i} = \pm 1\)</span> chosen uniformly at random.</p></li>
<li><p><span class="math inline">\(\mathbf{H} \in \mathbb{R}^{n \times n}\)</span> is a Hadamard matrix.</p></li>
</ul>
<p>The Hadamard matrix is an orthogonal matrix closely related to the discrete Fourier matrix. It has three critical properties:</p>
<ol type="1">
<li><p><span class="math inline">\(\| \mathbf{Hx} \|_2^2 = \|\mathbf{x}\|_2^2\)</span> <em>exactly</em>. Thus <span class="math inline">\(\| \mathbf{HDx} \|_2^2 = \|\mathbf{Dx}\|_2^2 = \|\mathbf{x}\|_2^2\)</span>.</p></li>
<li><p><span class="math inline">\(\mathbf{Hx}\)</span> can be computed in <span class="math inline">\(O(n \log n)\)</span> time.</p></li>
<li><p>All of the entries in <span class="math inline">\(\mathbf{H}\)</span> have the same magnitude.</p></li>
</ol>
<p>We will assume that <span class="math inline">\(n\)</span> is a power of 2. For <span class="math inline">\(k=0,1,\ldots\)</span>, the <span class="math inline">\(k\)</span>th Hadamard matrix <span class="math inline">\(\mathbf{H}_k\)</span> is defined recursively as</p>
<p><span class="math display">\[\begin{align*}
\mathbf{H}_0 &amp;= \begin{bmatrix} 1 \end{bmatrix} \\
\mathbf{H}_1 &amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix} \\
\mathbf{H}_2 &amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} \mathbf{H}_1 &amp; \mathbf{H}_1 \\ \mathbf{H}_1 &amp; -\mathbf{H}_1 \end{bmatrix} \\
\mathbf{H}_k &amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} \mathbf{H}_{k-1} &amp; \mathbf{H}_{k-1} \\ \mathbf{H}_{k-1} &amp; -\mathbf{H}_{k-1} \end{bmatrix}.
\end{align*}\]</span></p>
<p>The <span class="math inline">\(n\)</span> by <span class="math inline">\(n\)</span> Hadamard matrix has all entries equal to <span class="math inline">\(\pm 1/\sqrt{n}\)</span>.</p>
<p><strong>Property 1:</strong> For any <span class="math inline">\(k = 0,1,\ldots\)</span>, we have <span class="math inline">\(\| \mathbf{H}_k \mathbf{x} \|_2^2 = \|\mathbf{x}\|_2^2\)</span> for all <span class="math inline">\(\mathbf{x} \in \mathbb{R}^n\)</span>. That is, <span class="math inline">\(\mathbf{H}_k\)</span> is orthogonal.</p>
<p>We will show the property via induction. Assume the property holds for <span class="math inline">\(\mathbf{H}_{k-1}\)</span> so <span class="math inline">\(\mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} = \mathbf{I}_{2^{k-1}}\)</span>. Then <span class="math display">\[\begin{align*}
\mathbf{H}_k^\top \mathbf{H}_k
&amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} \mathbf{H}_{k-1}^\top &amp; \mathbf{H}_{k-1}^\top \\ \mathbf{H}_{k-1}^\top &amp; -\mathbf{H}_{k-1}^\top \end{bmatrix}
\frac{1}{\sqrt{2}} \begin{bmatrix} \mathbf{H}_{k-1} &amp; \mathbf{H}_{k-1} \\ \mathbf{H}_{k-1} &amp; -\mathbf{H}_{k-1} \end{bmatrix} \\
&amp;= \frac{1}{2} \begin{bmatrix} \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} + \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} &amp; \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} - \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} \\ \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} - \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} &amp; \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} + \mathbf{H}_{k-1}^\top \mathbf{H}_{k-1} \end{bmatrix} \\
&amp;= \frac{1}{2} \begin{bmatrix} 2\mathbf{I}_{2^{k-1}} &amp; 0 \\ 0 &amp; 2\mathbf{I}_{2^{k-1}} \end{bmatrix} = \mathbf{I}_{2^{k}}.
\end{align*}\]</span></p>
<p><strong>Property 2:</strong> We can compute <span class="math inline">\(\mathbf{\Pi x} = \mathbf{S HDx}\)</span> in <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Notice that <span class="math display">\[\begin{align*}
\mathbf{H}_kx
&amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} \mathbf{H}_{k-1} &amp; \mathbf{H}_{k-1} \\ \mathbf{H}_{k-1} &amp; -\mathbf{H}_{k-1} \end{bmatrix} \begin{bmatrix} \mathbf{x}_a \\ \mathbf{x}_b \end{bmatrix} \\
&amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} \mathbf{H}_{k-1} \mathbf{x}_a + \mathbf{H}_{k-1} \mathbf{x}_b \\ \mathbf{H}_{k-1} \mathbf{x}_a - \mathbf{H}_{k-1} \mathbf{x}_b \end{bmatrix}
\end{align*}\]</span> where <span class="math inline">\(\mathbf{x}_a\)</span> and <span class="math inline">\(\mathbf{x}_b\)</span> are the first and second halves of <span class="math inline">\(\mathbf{x}\)</span>. Since we only need to compute <span class="math inline">\(\mathbf{H}_{k-1} \mathbf{x}_a\)</span> and <span class="math inline">\(\mathbf{H}_{k-1} \mathbf{x}_b\)</span> each once,<span class="math inline">\(\mathbf{H}_k \mathbf{x}\)</span> is <span class="math inline">\(T(n) = 2T(n/2) + O(n) = O(n \log n)\)</span>.</p>
<p><strong>Property 3</strong>: The randomized Hadamard matrix <span class="math inline">\(\mathbf{HD}\)</span> is a good mixing matrix for smoothing out vectors.</p>
<p align="center">
<img src="images/hadamard_structured.png" width="200px"> <img src="images/hadamard_randomized.png" width="200px">
</p>
<p>The figure on the left is a Hadamard matrix <span class="math inline">\(\mathbf{H}\)</span> where blue squares are <span class="math inline">\(\frac1{\sqrt{n}}\)</span> and white squares are <span class="math inline">\(-\frac1{\sqrt{n}}\)</span>. The figure on the right is a randomized Hadamard matrix <span class="math inline">\(\mathbf{HD}\)</span>.</p>
<p>Pseudorandom objects like this appear all the time in computer science. For example, error correcting codes, efficient hash functions, and more.</p>
<p>We will prove the following.</p>
<p><strong>SHRT Mixing Lemma:</strong> Let <span class="math inline">\(\mathbf{H}\)</span> be an <span class="math inline">\(n \times n\)</span> Hadamard matrix and <span class="math inline">\(\mathbf{D}\)</span> be an <span class="math inline">\(n \times n\)</span> diagonal matrix with <span class="math inline">\(D_{i,i} = \pm 1\)</span> chosen uniformly at random. For any <span class="math inline">\(\mathbf{x} \in \mathbb{R}^n\)</span>, let <span class="math inline">\(\mathbf{z} = \mathbf{HDx}\)</span>. Then, with probability at least <span class="math inline">\(1-\delta\)</span>, we have <span class="math display">\[
z_i^2 \leq \frac{c \log(n/\delta)}{n} \| \mathbf{z} \|_2^2
\]</span> for all <span class="math inline">\(i\)</span> where <span class="math inline">\(c\)</span> is a universal constant.</p>
<p><strong>Proof:</strong> Let <span class="math inline">\(\mathbf{h}_i^\top\)</span> be the <span class="math inline">\(i\)</span>th row of <span class="math inline">\(\mathbf{H}\)</span>. Then <span class="math inline">\(z_i = \mathbf{h}_i^\top \mathbf{Dx}\)</span> and <span class="math display">\[\begin{align*}
\mathbf{h}_i^\top \mathbf{D} = \frac{1}{\sqrt{n}} \begin{bmatrix} 1 &amp; 1 &amp; \cdots &amp; - 1 &amp; -1 \end{bmatrix}
\begin{bmatrix} D_{1,1} \\ &amp; D_{2,2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; D_{n,n} \end{bmatrix}
\end{align*}\]</span> where <span class="math inline">\(D_{1,1}, \ldots, D_{n,n}\)</span> are independent random variables with <span class="math inline">\(D_{,j} = \pm 1\)</span> chosen uniformly at random. Equivalently, <span class="math display">\[\begin{align*}
\mathbf{h}_i^\top \mathbf{D} = \frac{1}{\sqrt{n}} \begin{bmatrix} R_1 &amp; R_2  &amp; \ldots &amp; R_n \end{bmatrix}
\end{align*}\]</span> where <span class="math inline">\(R_1, \ldots, R_n\)</span> are independent random variables with <span class="math inline">\(R_j = \pm 1\)</span> chosen uniformly at random. Then <span class="math inline">\(z_i = \frac{1}{\sqrt{n}} \sum_{j=1}^n R_j x_j\)</span>. Notice that <span class="math inline">\(z_i\)</span> is a random variable with mean 0 and variance <span class="math inline">\(\frac{1}{n} \| \mathbf{x} \|_2^2\)</span>.</p>
<p>To see this, we can write <span class="math display">\[\begin{align*}
\mathbb{E} \left[ z_i \right]
= \frac{1}{\sqrt{n}} \sum_{j=1}^n x_j \mathbb{E} \left[ R_j \right] = 0
\end{align*}\]</span> and, by linearity of variance, <span class="math display">\[\begin{align*}
\textrm{Var} \left[ z_i \right]
= \frac{1}{n} \sum_{j=1}^n x_j^2 \textrm{Var} \left[ R_j \right] = \frac{1}{n} \sum_{i=1}^n x_i^2 = \frac{1}{n} \| \mathbf{x} \|_2^2.
\end{align*}\]</span></p>
<p>We will apply a Bernstein type concentration inequality to prove the bound.</p>
<p><strong>Rademacher Concentration:</strong> Let <span class="math inline">\(R_1, \ldots, R_n\)</span> be independent random variables with <span class="math inline">\(R_j = \pm 1\)</span> chosen uniformly at random. Then, for any <span class="math inline">\(t &gt; 0\)</span> and vector <span class="math inline">\(\mathbf{a} \in \mathbb{R}^n\)</span>, we have <span class="math display">\[
\Pr \left(
\sum_{i=1}^n R_i a_i \geq t \| \mathbf{a} \|_2
\right)
\leq e^{-t^2/2}.
\]</span></p>
<p>This inequality is called the Khintchine inequality. It is specialized to sums of scaled <span class="math inline">\(\pm 1\)</span>’s and is a bit tighter and easier to apply than the generic Bernstein bound.</p>
<p>Applying the inequality, we have, with probability <span class="math inline">\(1-\delta\)</span>, <span class="math display">\[\begin{align*}
z_i \leq \sqrt{ \frac{c \log(n/\delta)}{n} \|} \mathbf{x} \|_2 = \sqrt{ \frac{c \log(n/\delta)}{n} \|} \mathbf{z} \|_2
\end{align*}\]</span> where the second equality follows because multiplying by <span class="math inline">\(\mathbf{H}\)</span> and <span class="math inline">\(\mathbf{D}\)</span> preserve the <span class="math inline">\(\ell_2\)</span>-norm. As shown earlier, we can thus guarantee that <span class="math display">\[
(1-\epsilon) \| \mathbf{z} \|_2^2 \leq \| \mathbf{Sz} \|_2^2 \leq (1+\epsilon) \| \mathbf{z} \|_2^2
\]</span> as long as <span class="math inline">\(\mathbf{S} \in \mathbb{R}^{m \times n}\)</span> is a subsampled randomized Hadamard transform with <span class="math inline">\(m = O\left(\frac{\log(n/\delta) \log(1/\delta)}{\epsilon^2}\right)\)</span>.</p>
<p>We have <span class="math inline">\(\| \mathbf{Sz} \|_2^2 = \| \mathbf{SHDx} \|_2^2 = \| \mathbf{\Pi x} \|_2^2\)</span> and <span class="math inline">\(\| \mathbf{z} \|_2^2 = \| \mathbf{x} \|_2^2\)</span> so we are done.</p>
<p>In words, the SHRT mixing lemma shows that the mixed vector is very close to uniform with high probability. As we saw earlier, we can therefore argue that <span class="math inline">\(\| \mathbf{S z} \|_2^2 \approx \| \mathbf{z} \|_2^2.\)</span></p>
<p>The main result then follows directly from our sampling result.</p>
<p><strong>Fast JL Lemma:</strong> Let <span class="math inline">\(\mathbf{\Pi} = \mathbf{SHD} \in \mathbb{R}^{m \times n}\)</span> be a subsampled randomized Hadamard transform with <span class="math inline">\(m = O\left(\frac{\log(n/\delta) \log(1/\delta)}{\epsilon^2}\right)\)</span>. Then, for any fixed <span class="math inline">\(\mathbf{x}\)</span>, we have <span class="math display">\[
(1-\epsilon) \| \mathbf{x} \|_2^2 \leq \| \mathbf{\Pi x} \|_2^2 \leq (1+\epsilon) \| \mathbf{x} \|_2^2
\]</span> with probability <span class="math inline">\(1-\delta\)</span>.</p>
<p>We can apply the theorem to regression. We compute <span class="math inline">\(\mathbf{\Pi A}\)</span> in <span class="math inline">\(O(nd \log n)\)</span> time instead of <span class="math inline">\(O(nd^2)\)</span> time. This is because there are <span class="math inline">\(d\)</span> columns and each column can be computed in <span class="math inline">\(O(n \log n)\)</span> time. The result is quite impressive because there are only <span class="math inline">\(O(nd)\)</span> entries in <span class="math inline">\(\mathbf{A}\)</span> so the projection is nearly linear.</p>
<p>However, we may want to go faster when <span class="math inline">\(\mathbf{A}\)</span> is sparse. For this setting, Clarkson and Woodruff in 2013 <a href="https://arxiv.org/abs/1207.6365">showed</a> that we can compute <span class="math inline">\(\mathbf{\Pi A}\)</span> with an ultra-sparse matrix in <span class="math inline">\(O(\text{nnz}(\mathbf{A}))\)</span> time where <span class="math inline">\(\text{nnz}(\mathbf{A})\)</span> is the number of non-zero entries in <span class="math inline">\(\mathbf{A}\)</span>. The proofs use totally different techniques than the Johnson-Lindenstrauss and <span class="math inline">\(\epsilon\)</span>-net arguments we used.</p>
<p>We covered this algorithm because it is simple and easy to implement. The algorithm has also been used for accelerating vector dimensionality reduction, linear algebra, locality sensitive hasing, and randomized kernel learning methods.</p>




</main> <!-- /main -->
<script>
document.addEventListener("DOMContentLoaded", function () {
  const wordsPerMinute = 200;
  const text = document.body.innerText;
  const words = text.trim().split(/\s+/).length;
  const readingTime = Math.ceil(words / wordsPerMinute);

  const readTimeEl = document.createElement("div");
  readTimeEl.innerText = `⏱️ ${readingTime} min read`;

  // Style it to appear centered
  readTimeEl.style.fontSize = "0.9em";
  readTimeEl.style.margin = "1em auto";
  readTimeEl.style.textAlign = "left";
  readTimeEl.style.width = "100%";

  const title = document.querySelector("h1");
  if (title) {
    title.parentNode.insertBefore(readTimeEl, title.nextSibling);
  }
});
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>