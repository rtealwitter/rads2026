<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sketched Regression</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c5a5d5e27fcc88644031c24cff017230.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="shortcut icon" href="../favicon.ico">
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GZHXTPTRRE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GZHXTPTRRE');
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Spring 2026</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://discord.gg/dES3fSPEeC"> 
<span class="menu-text">Discord</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.gradescope.com/courses/1091652"> 
<span class="menu-text">Gradescope</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Sketched Regression</strong></h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<p>Consider a matrix <span class="math inline">\(\mathbf{M} \in \mathbb{R}^{n \times n}\)</span>. The main idea of randomized numerical linear algebra is to compress a matrix using a randomized method such as subsampling and then solve the problem we are interested in on the compressed matrix.</p>
<p>For example, we can approximately multiply two matrices by subsampling the rows and columns of the matrices.</p>
<p align="center">
<img src="images/sampling_column_reduction.png" width="400px">
</p>
<p>We can also approximately solve regression problems by subsampling the rows of the matrix.</p>
<p align="center">
<img src="images/subsampled_regression.png" width="400px">
</p>
<p>Today, we will discuss randomized approximate regression using a Johnson-Lindenstrauss matrix for compression.</p>
<p>The input is a matrix <span class="math inline">\(\mathbf{A} \in \mathbb{R}^{n \times d}\)</span> and a vector <span class="math inline">\(\mathbf{b} \in \mathbb{R}^n\)</span>.</p>
<p>Consider the optimal solution to the least squares problem <span class="math display">\[
\mathbf{x}^* = \arg \min_{\mathbf{x} \in \mathbb{R}^d} \| \mathbf{A} \mathbf{x} - \mathbf{b} \|_2^2
\]</span> and the approximate solution <span class="math display">\[
\tilde{\mathbf{x}} = \arg \min_{\mathbf{x} \in \mathbb{R}^d} \| \mathbf{\Pi} \mathbf{A} \mathbf{x} - \mathbf{\Pi} \mathbf{b} \|_2^2
\]</span></p>
<p>where <span class="math inline">\(\mathbf{\Pi} \in \mathbb{R}^{m \times n}\)</span> is a Johnson-Lindenstrauss matrix with <span class="math inline">\(m \ll n\)</span> rows.</p>
<p>The goal is to show that the quality of the approximate solution is close to the quality of the optimal solution.</p>
<p><strong>Randomized Linear Regression:</strong> Let <span class="math inline">\(\mathbf{\Pi}\)</span> be a properly scaled JL matrix (random Gaussian, random sign, sparse matrix, etc.) with <span class="math inline">\(m = O(d/\epsilon^2)\)</span> rows. Then, with probability <span class="math inline">\(9/10\)</span>, for any <span class="math inline">\(\mathbf{A} \in \mathbb{R}^{n \times d}\)</span> and <span class="math inline">\(\mathbf{b} \in \mathbb{R}^n\)</span>, <span class="math display">\[
\| \mathbf{A} \tilde{\mathbf{x}} - \mathbf{b} \|_2^2
\leq
(1+\epsilon)
\| \mathbf{A} \mathbf{x}^* - \mathbf{b} \|_2^2.
\]</span></p>
<p>We will prove the theorem using an <span class="math inline">\(\epsilon\)</span>-net argument. The technique is a popular approach for applying our standard concentration inequality and union bound argument to an infinite number of events. While the result we consider today is interesting, our real motivation is to explore this kind of argument because it appears in many other contexts in theoretical computer science and machine learning.</p>
<p>In order to prove the theorem, we will prove the following claim.</p>
<p><strong>Claim:</strong> For all <span class="math inline">\(\mathbf{x} \in \mathbb{R}^d\)</span>, <span class="math display">\[\begin{align*}
(1-\epsilon) \| \mathbf{A} \mathbf{x} - \mathbf{b} \|_2^2
\leq \| \mathbf{\Pi} \mathbf{A} \mathbf{x} - \mathbf{\Pi} \mathbf{b} \|_2^2
\leq (1+\epsilon) \| \mathbf{A} \mathbf{x} - \mathbf{b} \|_2^2.
\end{align*}\]</span></p>
<p>With the claim, we can prove the theorem since <span class="math display">\[\begin{align*}
\| \mathbf{A} \tilde{\mathbf{x}} - \mathbf{b} \|_2^2
&amp;\leq \frac1{1-\epsilon} \| \mathbf{\Pi} \mathbf{A} \tilde{\mathbf{x}} - \mathbf{\Pi} \mathbf{b} \|_2^2 \\
&amp; \leq \frac1{1-\epsilon}  \| \mathbf{\Pi A} \mathbf{x}^* - \mathbf{\Pi b} \|_2^2 \\
&amp; \leq \frac{1+\epsilon}{1-\epsilon} \| \mathbf{A} \mathbf{x}^* - \mathbf{b} \|_2^2
\end{align*}\]</span> where the first and third inequalities are by the claim and the second inequality is by the optimality of <span class="math inline">\(\tilde{\mathbf{x}}\)</span> for the compressed regression problem.</p>
<p>Recall the following lemma that we previously proved.</p>
<p><strong>Distributional JL Lemma</strong>: If <span class="math inline">\(\mathbf{\Pi}\)</span> is a properly scaled JL matrix with <span class="math inline">\(m = O(\log(1/\delta) /\epsilon^2)\)</span> rows then for any fixed <span class="math inline">\(\mathbf{y}\)</span>, <span class="math display">\[
(1-\epsilon) \| \mathbf{y} \|_2^2
\leq \| \mathbf{\Pi} \mathbf{y} \|_2^2
\leq (1+\epsilon) \| \mathbf{y} \|_2^2
\]</span> with probabiity <span class="math inline">\(1-\delta\)</span>.</p>
<p>The challenge in going from the distributional JL lemma to the claim is that the JL lemma only holds for a fixed vector <span class="math inline">\(\mathbf{y}\)</span> whereas we need it to hold for an <em>infinite</em> number of vectors.</p>
<p>Note that all vectors of the form <span class="math inline">\(\mathbf{Ax - b}\)</span> lie in a low dimensional space spanned by <span class="math inline">\(d+1\)</span> vectors where <span class="math inline">\(d\)</span> is the number of columns in <span class="math inline">\(\mathbf{A}\)</span>. So even though the set is infinite, it is “simple” in some sense.</p>
<p>Our goal is to prove the following theorem.</p>
<p><strong>Subspace Embedding Theorem:</strong> Let <span class="math inline">\(\mathcal{U} \subset \mathbb{R}^n\)</span> be a <span class="math inline">\(d\)</span>-dimensional subspace. If <span class="math inline">\(\mathbf{\Pi}\)</span> is chosen from any distribution satisfying the distributional JL Lemma, then with probability <span class="math inline">\(1-\delta\)</span>, <span class="math display">\[
(1-\epsilon) \| \mathbf{y} \|_2^2
\leq \| \mathbf{\Pi} \mathbf{y} \|_2^2
\leq (1+\epsilon) \| \mathbf{y} \|_2^2
\]</span> for all <span class="math inline">\(\mathbf{y} \in \mathcal{U}\)</span> as long as <span class="math inline">\(m = O \left( \frac{d \log(1/\epsilon) + \log(1/\delta)}{\epsilon^2} \right)\)</span>.</p>
<p>It is possible to obtain a slightly tighter bound of <span class="math inline">\(O \left( \frac{d + \log(1/\delta)}{\epsilon^2} \right)\)</span> by using a more careful analysis.</p>
<p>If we can prove the subspace embedding theorem, the following corollary will follow.</p>
<p><strong>Corollary:</strong> If we choose <span class="math inline">\(\mathbf{\Pi}\)</span> and properly scale, then with <span class="math inline">\(O(d/\epsilon^2)\)</span> rows, <span class="math display">\[
(1-\epsilon) \| \mathbf{Ax - b} \|_2^2
\leq \| \mathbf{\Pi} \mathbf{Ax - \Pi b} \|_2^2
\leq (1+\epsilon) \| \mathbf{Ax - b} \|_2^2
\]</span> for all <span class="math inline">\(\mathbf{x}\)</span> and therefore <span class="math display">\[
\| \mathbf{A} \tilde{\mathbf{x}} - \mathbf{b} \|_2^2
\leq (1+O(\epsilon)) \| \mathbf{A} \mathbf{x}^* - \mathbf{b} \|_2^2.
\]</span></p>
<p>We can prove the corollary by applying the subspace embedding theorem to the <span class="math inline">\(d+1\)</span> dimensional subspace spanned by the <span class="math inline">\(d\)</span> columns of <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{b}\)</span>. Every vector <span class="math inline">\(\mathbf{A x -b}\)</span> lies in this space.</p>
<p>The first observation in proving the subspace embedding theorem is that it suffices to prove it for all vectors <span class="math inline">\(\mathbf{w}\)</span> on the unit sphere in <span class="math inline">\(\mathcal{U}\)</span>. This observation follows from linearity: Any point <span class="math inline">\(\mathbf{v} \in \mathcal{U}\)</span> can be written as <span class="math inline">\(c \mathbf{w}\)</span> for some sclar <span class="math inline">\(c\)</span> and some point <span class="math inline">\(\mathbf{w}\)</span> the sphere <span class="math inline">\(S_{\mathcal{U}} = \{ \mathbf{w} \in \mathcal{U} : \| \mathbf{w} \|_2 = 1 \}\)</span>. If <span class="math display">\[\begin{align*}
(1-\epsilon) \| \mathbf{w} \|_2
\leq \| \mathbf{\Pi} \mathbf{w} \|_2
\leq (1+\epsilon) \| \mathbf{w} \|_2
\end{align*}\]</span> then <span class="math display">\[\begin{align*}
c(1-\epsilon) \| \mathbf{w} \|_2
\leq c \| \mathbf{\Pi} \mathbf{w} \|_2
\leq c(1+\epsilon) \| \mathbf{w} \|_2
\end{align*}\]</span> and therefore <span class="math display">\[\begin{align*}
(1-\epsilon) \| c \mathbf{w} \|_2
\leq \| \mathbf{\Pi} c \mathbf{w} \|_2
\leq (1+\epsilon) \| c \mathbf{w} \|_2.
\end{align*}\]</span></p>
<p>Now that we have restricted our problem to proving the theorem on the unit sphere, our intuiton is that there are not too many “different” points on a <span class="math inline">\(d\)</span>-dimensional sphere.</p>
<p align="center">
<img src="images/epsilon_net.png" width="200px">
</p>
<p>We call <span class="math inline">\(\mathcal{N}_\epsilon\)</span> the <span class="math inline">\(\epsilon\)</span>-net that includes a representative set of points. If we can prove that <span class="math display">\[\begin{align*}
(1-\epsilon) \| \mathbf{w} \|_2
\leq \| \mathbf{\Pi} \mathbf{w} \|_2
\leq (1+\epsilon) \| \mathbf{w} \|_2
\end{align*}\]</span> for all points <span class="math inline">\(\mathbf{w} \in \mathcal{N}_\epsilon\)</span>, we can hopefully extend the result to all points on the sphere.</p>
<p><strong>Lemma (Epsilon Net):</strong> For any <span class="math inline">\(\epsilon \leq 1\)</span>, there exists a set <span class="math inline">\(\mathcal{N}_\epsilon \subset S_\mathcal{U}\)</span> with <span class="math inline">\(| \mathcal{N}_\epsilon | \leq \left( \frac{4}{\epsilon} \right)^d\)</span> such that for all <span class="math inline">\(\mathbf{v} \in \mathcal{S}\)</span>, <span class="math display">\[
\min_{\mathbf{w} \in \mathcal{N}_\epsilon} \| \mathbf{v} - \mathbf{w} \|_2 \leq \epsilon.
\]</span></p>
<p><strong>Proof:</strong></p>
<p>We will construct the <span class="math inline">\(\epsilon\)</span>-net by a greedy algorithm. Initially, the epsilon <span class="math inline">\(\mathcal{N}_\epsilon\)</span> is empty. While there is a point <span class="math inline">\(\mathbf{v}\)</span> on the sphere that is not within <span class="math inline">\(\epsilon\)</span> of any point in <span class="math inline">\(\mathcal{N}_\epsilon\)</span>, we will add <span class="math inline">\(\mathbf{v}\)</span> to <span class="math inline">\(\mathcal{N}_\epsilon\)</span>. After running the algorithm, we will have a set <span class="math inline">\(\mathcal{N}_\epsilon\)</span> such that <span class="math display">\[
\min_{\mathbf{w} \in \mathcal{N}_\epsilon} \| \mathbf{v} - \mathbf{w} \|_2 \leq \epsilon.
\]</span> (Otherwise, the procedure would not have terminated.) It remains to show that the <span class="math inline">\(\epsilon\)</span>-net is not too large.</p>
<p align="center">
<img src="images/net_argument.png" width="200px">
</p>
<p>We can count the number of points in the <span class="math inline">\(\epsilon\)</span>-net by considering the volume of the sphere. Each point in the net is at least <span class="math inline">\(\epsilon\)</span> away from every other point in the net (otherwise, the point would not have been added). So we can imagine a ball of radius <span class="math inline">\(\frac{\epsilon}{2}\)</span> around each point in the net that does not overlap with any other ball. All of these balls live in a larger ball of radius <span class="math inline">\(1+\frac{\epsilon}{2}\)</span>. Let’s count the number of non-overlapping balls of radius <span class="math inline">\(\frac{\epsilon}{2}\)</span> that fit in the larger ball of radius <span class="math inline">\(1+\frac{\epsilon}{2}\)</span>. We know that the volume of a ball with radius <span class="math inline">\(r\)</span> in <span class="math inline">\(d\)</span> dimensions is <span class="math display">\[
\text{vol}(d,r) = c \cdot r^d
\]</span> where <span class="math inline">\(c\)</span> is a constant that depends on the dimension but not on the radius.</p>
<p>Because all the small balls are non-overlapping and live in the larger ball, we know <span class="math display">\[\begin{align*}
\text{vol}\left(d,\frac{\epsilon}{2} \right) | \mathcal{N}_\epsilon |
&amp;\leq \text{vol}(d,1+\frac{\epsilon}{2}) \\
| \mathcal{N}_\epsilon | &amp;\leq \frac{\text{vol}(d,1+\frac{\epsilon}{2})}{\text{vol}(d,\frac{\epsilon}{2})} \\
&amp;\leq \frac{(1+\frac{\epsilon}{2})^d}{(\frac{\epsilon}{2})^d} \leq \left( \frac{3}{\epsilon} \right)^d
\end{align*}\]</span></p>
<p>With this claim in hand, we will first consider how to preserve the norms of all points in the net <span class="math inline">\(\mathcal{N}_\epsilon\)</span>. Set <span class="math inline">\(\delta' = \frac1{|\mathcal{N}_\epsilon|} \delta
= \left(\frac{\epsilon}{4} \right)^d \delta\)</span>. As long as <span class="math inline">\(\mathbf{\Pi}\)</span> has</p>
<p><span class="math display">\[O \left( \frac{\log(1/\delta')}{\epsilon^2} \right) =
O \left( \frac{d \log(1/\epsilon) + \log(1/\delta)}{\epsilon^2} \right)\]</span> rows, then by a union bound, <span class="math display">\[
(1-\epsilon) \| \mathbf{w} \|_2^2
\leq \| \mathbf{\Pi} \mathbf{w} \|_2^2
\leq (1+\epsilon) \| \mathbf{w} \|_2^2
\]</span> for all <span class="math inline">\(\mathbf{w} \in \mathcal{N}_\epsilon\)</span> with probability <span class="math inline">\(1-\delta\)</span>.</p>
<p>Next, we will extend the result to all points on the sphere. For some set of points in the net <span class="math inline">\(\mathbf{w}_0, \mathbf{w}_1, \mathbf{w}_2, \ldots, \in \mathcal{N}_\epsilon\)</span>, any point on the sphere <span class="math inline">\(\mathbf{v} \in S_\mathcal{U}\)</span> can be written as <span class="math display">\[
\mathbf{v} = \mathbf{w}_0 + c_1 \mathbf{w}_1 + c_2 \mathbf{w}_2 + \ldots
\]</span> for constants <span class="math inline">\(c_1, c_2, \ldots\)</span> where <span class="math inline">\(|c_i| \leq \epsilon^i\)</span>.</p>
<p>We can prove this through a greedy construction and the <span class="math inline">\(\epsilon\)</span>-net property. <span class="math display">\[\begin{align*}
\mathbf{w}_0 &amp;= \arg \min_{\mathbf{w} \in \mathcal{N}_\epsilon} \| \mathbf{v} - \mathbf{w} \|_2
\qquad \mathbf{r}_0 = \mathbf{v} - \mathbf{w}_0 \qquad c_1 = \| \mathbf{r_0} \|_2 \\
\mathbf{w}_1 &amp;= \arg \min_{\mathbf{w} \in \mathcal{N}_\epsilon} \| \frac{\mathbf{r}_0}{c_1} - \mathbf{w} \|_2
\qquad \mathbf{r}_1 = \mathbf{v} - \mathbf{w}_0 - c_1 \mathbf{w}_1
\qquad c_2 = \| \mathbf{r}_1 \|_2  \\
\mathbf{w}_2 &amp;= \arg \min_{\mathbf{w} \in \mathcal{N}_\epsilon} \| \frac{\mathbf{r}_1}{c_2} - \mathbf{w} \|_2
\qquad \mathbf{r}_2 = \mathbf{v} - \mathbf{w}_0 - c_1 \mathbf{w}_1 - c_2 \mathbf{w}_2
\qquad c_3 = \| \mathbf{r}_2 \|_2 \\
&amp;\vdots
\end{align*}\]</span> We will inductively prove that <span class="math inline">\(\| \mathbf{r}_i \|_2 \leq \epsilon^i\)</span>. To see this, observe that <span class="math display">\[\begin{align*}
\left\| \frac{\mathbf{r}_{i-1}}{c_{i}} - \mathbf{w}_i \right\|_2
\leq \epsilon
\end{align*}\]</span> by the property of the <span class="math inline">\(\epsilon\)</span>-net. Multiplying by <span class="math inline">\(\| \mathbf{r}_{i-1} \|_2\)</span> gives <span class="math display">\[\begin{align*}
\| \mathbf{r}_i \|_2 =
\| \mathbf{r}_{i-1} - c_i \mathbf{w}_i \|_2
\leq \epsilon c_i = \epsilon \| \mathbf{r}_{i-1} \|_2
\end{align*}\]</span> The inductive claim follows.</p>
<p>Applying triangle inequality, we have that <span class="math display">\[\begin{align*}
\| \mathbf{\Pi v} \|_2 &amp;=
\| \mathbf{\Pi w}_0 + c_1 \mathbf{\Pi w}_1 + c_2 \mathbf{\Pi w}_2 + \ldots \|_2 \\
&amp;\leq \| \mathbf{\Pi w}_0 \|_2 + c_1 \| \mathbf{\Pi w}_1 \|_2 + c_2 \| \mathbf{\Pi w}_2 \|_2 + \ldots \\
&amp;\leq \| \mathbf{\Pi w}_0 \|_2 + \epsilon \| \mathbf{\Pi w}_1 \|_2 + \epsilon^2 \| \mathbf{\Pi w}_2 \|_2 + \ldots \\
&amp;\leq (1+\epsilon) \| \mathbf{w}_0 \|_2 + \epsilon (1+\epsilon) \| \mathbf{w}_1 \|_2 + \epsilon^2 (1+\epsilon) \| \mathbf{w}_2 \|_2 + \ldots \\
&amp;= 1 + 2 \epsilon + 2 \epsilon^2 + 2 \epsilon^3 \ldots \\
&amp;\leq \frac{1}{1-2\epsilon} \leq 1 + 4\epsilon.
\end{align*}\]</span></p>
<p>For the other direction, we will use that <span class="math inline">\(\| \mathbf{a} + \mathbf{b} \|_2 \geq \| \mathbf{a} \|_2 - \| \mathbf{b} \|_2\)</span>. To see this, observe that <span class="math inline">\(\| \mathbf{a} \|_2 \leq \| \mathbf{a} + \mathbf{b} \|_2 + \| \mathbf{b} \|_2\)</span> by the triangle inequality applied to the vectors <span class="math inline">\(\mathbf{a} + \mathbf{b}\)</span> and <span class="math inline">\(-\mathbf{b}\)</span>. By repeatedly applying this inequality, we have that <span class="math display">\[\begin{align*}
\| \mathbf{\Pi v} \|_2 &amp;=
\| \mathbf{\Pi w}_0 + c_1 \mathbf{\Pi w}_1 + c_2 \mathbf{\Pi w}_2 + \ldots \|_2 \\
&amp;\geq \| \mathbf{\Pi w}_0 \|_2 - c_1 \| \mathbf{\Pi w}_1 \|_2 - c_2 \| \mathbf{\Pi w}_2 \|_2 - \ldots \\
&amp;\geq \| \mathbf{\Pi w}_0 \|_2 - \epsilon \| \mathbf{\Pi w}_1 \|_2 - \epsilon^2 \| \mathbf{\Pi w}_2 \|_2 - \ldots \\
&amp;\geq (1-\epsilon) \| \mathbf{w}_0 \|_2 - \epsilon (1-\epsilon) \| \mathbf{w}_1 \|_2 - \epsilon^2 (1-\epsilon) \| \mathbf{w}_2 \|_2 - \ldots \\
&amp;= 1 - 2 \epsilon + 2 \epsilon^2 - 2 \epsilon^3 \ldots \\
&amp;\geq \frac{1}{1+2\epsilon} \geq 1 - 4\epsilon.
\end{align*}\]</span></p>
<p>So we have proven that <span class="math display">\[\begin{align*}
(1-O(\epsilon)) \| \mathbf{v} \|_2
\leq \| \mathbf{\Pi v} \|_2
\leq (1+O(\epsilon)) \| \mathbf{v} \|_2
\end{align*}\]</span> for all vectors <span class="math inline">\(\mathbf{v}\)</span> on the sphere. Adjusting <span class="math inline">\(\epsilon\)</span> gives the subspace embedding theorem.</p>




</main> <!-- /main -->
<script>
document.addEventListener("DOMContentLoaded", function () {
  const wordsPerMinute = 200;
  const text = document.body.innerText;
  const words = text.trim().split(/\s+/).length;
  const readingTime = Math.ceil(words / wordsPerMinute);

  const readTimeEl = document.createElement("div");
  readTimeEl.innerText = `⏱️ ${readingTime} min read`;

  // Style it to appear centered
  readTimeEl.style.fontSize = "0.9em";
  readTimeEl.style.margin = "1em auto";
  readTimeEl.style.textAlign = "left";
  readTimeEl.style.width = "100%";

  const title = document.querySelector("h1");
  if (title) {
    title.parentNode.insertBefore(readTimeEl, title.nextSibling);
  }
});
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>